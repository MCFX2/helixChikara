enum Ship {Anime, MachoCheese, Reagan, Scout}

class PlayerController : ZilchComponent
{
  //controls
  [Property] var UpKey : Keys = Keys.W;
  [Property] var LeftKey : Keys = Keys.A;
  [Property] var DownKey : Keys = Keys.S;
  [Property] var RightKey : Keys = Keys.D;
  [Property] var PauseKey : Keys = Keys.Control;
  
  
  
  //physics constants
  [Property] var LSpeed = 0.5; //left acceleration modifier
  [Property] var RSpeed = 1.0; //right acceleration modifier
  [Property] var VSpeed = 1.0; //vertical acceleration multiplier
  [Property] var Speed = 1.0; //base acceleration
  
  [Property] var Deceleration : Real2 = Real2(0.2); //deceleration X,Y. Lower = slippery
  
  [Property] var MaxRVel = 10.0; //max right velocity
  [Property] var MaxLVel = 10.0; //max left velocity
  [Property] var MaxVVel = 10.0; //max vertical velocity
  
  //player vars
  var CurrentShip : Ship = Ship.Anime;
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    Zero.Connect(Zero.Keyboard, Events.KeyDown, this.OnKeyDown);
  }
  function Clamp(input : Real, min : Real, max : Real) : Real{ //Clamp input between max and min
    if(input <= min){
      return min;
    }
    else if(input >= max){
      return max;
    }
    else{
      return input;
    }
  }
  


  function ClampVelocity(){ //clamp our velocity within bounds specified in Properties
    this.Owner.RigidBody.Velocity = Real3( //split into several lines for readability
      this.Clamp(this.Owner.RigidBody.Velocity.X, -1 * this.MaxLVel, this.MaxRVel),
      this.Clamp(this.Owner.RigidBody.Velocity.Y, this.MaxVVel * -1, this.MaxVVel), 0
    );
  }
  
  function ChangeShip(newShip : Ship){
    this.CurrentShip = newShip;
    //do other stuff we do when switching here
  }
  
  function ParseKeyboard() : Real2 { //used for key inputs that DIRECTLY AFFECT acceleration
    var velocity : Real2 = Real2(0);
    if(Zero.Keyboard.KeyIsDown(this.RightKey)){
      velocity.X += this.RSpeed * this.Speed;
    }
    if(Zero.Keyboard.KeyIsDown(this.LeftKey)){
      velocity.X -= this.LSpeed * this.Speed;
    }
    if(Zero.Keyboard.KeyIsDown(this.UpKey)){
      velocity.Y += this.VSpeed * this.Speed;
    }
    if(Zero.Keyboard.KeyIsDown(this.DownKey)){
      velocity.Y -= this.VSpeed * this.Speed;
    }
    return velocity;
  }
  
  function Decelerate(){
      if(Math.Abs(this.Owner.RigidBody.Velocity.X) < this.Deceleration.X){ //to avoid sperging we set to 0 and forget if speed is too small
        this.Owner.RigidBody.Velocity = Real3(0, this.Owner.RigidBody.Velocity.Y, 0);
      }
      else if(this.Owner.RigidBody.Velocity.X > 0){ //accelerate towards 0
        this.Owner.RigidBody.Velocity -= Real3(this.Deceleration.X, 0, 0);
      }
      else{
        this.Owner.RigidBody.Velocity += Real3(this.Deceleration.X, 0, 0);
      }
      //again but for Y
      if(Math.Abs(this.Owner.RigidBody.Velocity.Y) < this.Deceleration.Y){
        this.Owner.RigidBody.Velocity = Real3(this.Owner.RigidBody.Velocity.X, 0, 0);
      }
      else if(this.Owner.RigidBody.Velocity.Y > 0){ //accelerate towards 0
        this.Owner.RigidBody.Velocity -= Real3(0, this.Deceleration.Y, 0);
      }
      else{
        this.Owner.RigidBody.Velocity += Real3(0, this.Deceleration.Y, 0);
      }
  }
  
  function Accelerate(){ //takes movement from all sources and smacks it into our final velocity
    var velVector : Real2 = Real2(0);
    velVector = this.ParseKeyboard();
    
    this.Owner.RigidBody.Velocity += Real3(velVector, 0); //this seems out of order, but there's a reason for it:
    this.Decelerate();
    /*
    When we take input, we build that input into a vector called velVector.
    Afterwards, we immediately apply that to our real velocity but then modify it again.
    The reason for this is because we need to know our real velocity for all future physics from here,
    and it's wasteful to copy our velocity when we can safely just write to it and read from it directly.
    */
    
  }
  
  function OnKeyDown(event : KeyboardEvent){ //pause
    if(event.Key == this.PauseKey){
      this.Space.TimeSpace.Paused = !this.Space.TimeSpace.Paused;
    }
  }

  function OnLogicUpdate(event : UpdateEvent)
  {
    this.Accelerate();
    this.ClampVelocity(); //clamping must be the last movement step
  }
  
}
