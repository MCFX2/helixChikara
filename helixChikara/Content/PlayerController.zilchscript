enum Ship {Anime, MachoCheese, Reagan, Scout}

class PlayerController : ZilchComponent
{
  //controls
  [Property] var UpKey : Keys = Keys.W;
  [Property] var LeftKey : Keys = Keys.A;
  [Property] var DownKey : Keys = Keys.S;
  [Property] var RightKey : Keys = Keys.D;
  [Property] var PauseKey : Keys = Keys.Control;
  [Property] var ShootKey : Keys = Keys.Space;
  [Property] var AnimeShipKey : Keys = Keys.NumPad1;
  [Property] var MachoCheeseShipKey : Keys = Keys.NumPad2;
  
  
  
  //physics constants
  [Property] var LSpeed = 0.5; //left acceleration modifier
  [Property] var RSpeed = 1.0; //right acceleration modifier
  [Property] var VSpeed = 1.0; //vertical acceleration multiplier
  [Property] var Speed = 1.0; //base acceleration
  
  [Property] var Deceleration : Real2 = Real2(0.2); //deceleration X,Y. Lower = slippery
  
  [Property] var MaxRVel = 10.0; //max right velocity
  [Property] var MaxLVel = 10.0; //max left velocity
  [Property] var MaxVVel = 10.0; //max vertical velocity
  var CorrectRotation : Quaternion = Quaternion();
  
  
  //rotation patching [DEPRECATED]
  
  [Property] var RotCorrectionStrict = true; //DEPRECATED whether to use strict rotation correction. Off = fun :)
  
  //bullet stuff TODO: make this its own script
  [Property] var BulletSpawnOffset = Real2(1.5, 0); //Bullet creation position relative to ship X, Y
  [Property] var BulletSpeedAnime = 2.5;
  [Property] var BulletFireDelay = 10; //number of logic ticks between reloads
  var TimeSinceLastBullet = 0;
  
  //player vars
  var CurrentShip : Ship = Ship.Anime;
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    Zero.Connect(this.Space, Events.FrameUpdate, this.OnFrameUpdate);
    Zero.Connect(Zero.Keyboard, Events.KeyDown, this.OnKeyDown);
    this.CorrectRotation = this.Owner.Transform.LocalRotation;
  }
  function Clamp(input : Real, min : Real, max : Real) : Real{ //Clamp input between max and min
    if(input <= min){
      return min;
    }
    else if(input >= max){
      return max;
    }
    else{
      return input;
    }
  }


  function ClampVelocity(){ //clamp our velocity within bounds specified in Properties
    this.Owner.RigidBody.Velocity = Real3( //split into several lines for readability
    this.Clamp(this.Owner.RigidBody.Velocity.X, -1 * this.MaxLVel, this.MaxRVel),
    this.Clamp(this.Owner.RigidBody.Velocity.Y, this.MaxVVel * -1, this.MaxVVel), 0);
    
  }
  
  function ChangeShip(newShip : Ship){
    this.CurrentShip = newShip;
    //do other stuff we do when switching here
  }
  
  function Shoot(){
    if(this.CurrentShip == Ship.Anime){
      if(this.TimeSinceLastBullet >= this.BulletFireDelay){
        var currentBullet : Cog = this.Space.CreateAtPosition(Archetype.AnimeBullet, this.Owner.Transform.Translation + Real3(this.BulletSpawnOffset, 0));
        currentBullet.RigidBody.Velocity = Real3(this.BulletSpeedAnime, 0, 0);
        //Note that bullets are intentionally NOT made children of Screen, so if the level changes direction bullets don't follow. Realism!
        this.TimeSinceLastBullet = 0;
      }
    }


    
    
  }
  
  function CheckKeyboard() { //used for any key inputs that do NOT DIRECTLY affect acceleration
    if(Zero.Keyboard.KeyIsDown(this.ShootKey)){
      this.Shoot();
    }
    if(Zero.Keyboard.KeyIsDown(this.AnimeShipKey)){//TODO. make a single ship key and use WAD to select a ship to replace from a radial menu
      this.ChangeShip(Ship.Anime);
    }
    if(Zero.Keyboard.KeyIsDown(this.MachoCheeseShipKey)){
      this.ChangeShip(Ship.MachoCheese);
    }
    
  }
  
  function ParseKeyboard() : Real2 { //used for key inputs that DIRECTLY AFFECT acceleration
    var velocity : Real2 = Real2(0);
    if(Zero.Keyboard.KeyIsDown(this.RightKey)){
      velocity.X += this.RSpeed * this.Speed;
    }
    if(Zero.Keyboard.KeyIsDown(this.LeftKey)){
      velocity.X -= this.LSpeed * this.Speed;
    }
    if(Zero.Keyboard.KeyIsDown(this.UpKey)){
      velocity.Y += this.VSpeed * this.Speed;
    }
    if(Zero.Keyboard.KeyIsDown(this.DownKey)){
      velocity.Y -= this.VSpeed * this.Speed;
    }
    return velocity;
  }
  
  function Accelerate(){ //takes movement from all sources and smacks it into our final velocity
    var velVector : Real2 = Real2(0);
    velVector = this.ParseKeyboard();    
    this.Owner.RigidBody.Velocity += Real3(velVector, 0); //this seems out of order, but there's a reason for it:
    
    /*
    When we take input, we build that input into a vector called velVector.
    Afterwards, we immediately apply that to our real velocity but then modify it again.
    The reason for this is because we need to know our real velocity for all future physics from here,
    and it's wasteful to copy our velocity when we can safely just write to it and read from it directly.
    */
    
    if(velVector == Real2(0)){ //if net input == 0
      if(Math.Abs(this.Owner.RigidBody.Velocity.X) < this.Deceleration.X){ //to avoid sperging we set to 0 and forget if speed is too small
        this.Owner.RigidBody.Velocity = Real3(0, this.Owner.RigidBody.Velocity.Y, 0);
      }
      else if(this.Owner.RigidBody.Velocity.X > 0){ //accelerate towards 0
        this.Owner.RigidBody.Velocity -= Real3(this.Deceleration.X, 0, 0);
      }
      else{
        this.Owner.RigidBody.Velocity += Real3(this.Deceleration.X, 0, 0);
      }
      
      //again but for Y
      if(Math.Abs(this.Owner.RigidBody.Velocity.Y) < this.Deceleration.Y){
        this.Owner.RigidBody.Velocity = Real3(this.Owner.RigidBody.Velocity.X, 0, 0);
      }
      else if(this.Owner.RigidBody.Velocity.Y > 0){ //accelerate towards 0
        this.Owner.RigidBody.Velocity -= Real3(0, this.Deceleration.Y, 0);
      }
      else{
        this.Owner.RigidBody.Velocity += Real3(0, this.Deceleration.Y, 0);
      }
    }
    
  }

  function FixRotation(){ //bumping obstacles can make us rotate. Let's fix that.
    if(this.RotCorrectionStrict){ //strict correction tries to force us to never rotate
      this.Owner.Transform.LocalRotation = this.CorrectRotation;
    }
  }

  
  function OnKeyDown(event : KeyboardEvent){ //pause
    if(event.Key == this.PauseKey){
      this.Space.TimeSpace.Paused = !this.Space.TimeSpace.Paused;
    }
  }

  function OnLogicUpdate(event : UpdateEvent)
  {
    this.FixRotation(); //deprecated
    this.CheckKeyboard();
    this.Accelerate();
    this.ClampVelocity(); //clamping must be the last movement step
    
    ++this.TimeSinceLastBullet;
  }
  
  function OnFrameUpdate(event : UpdateEvent){ //used for actions that should continue resolving while paused
    
  }
  
}
